# BDA - Modified ERC20 token

- Author: Jakub Kratochv√≠l (xkrato67)
- Date: April 2025

## Used technologies and libraries

For the smart contract developemnt I used foundry, since I find it pretty cool with all the tooling it has and also I already tried to use it in the intial homework. For the dApp development I used wagmi, react and using typescript. I chose wagmi because they have dark-mode on their website and I also found that it should be easier so I went with it.

## How to run it?

### Smart contract and local blockchain

When I implemented smart contracts and tests I needed to run the contract locally for better development of the dApp, thus I created simple deploy script which creates contract on the local anvil chain and mints some tokens for test user.

In the deploy script I used default addresses generated by the anvil. With this chain setup I also needed to configure metamask and run dApp which is described in the next section.

To run anvil and deploy contract (from project root dir):

```bash
anvil
# in a seperate terminal
forge script script/Deploy.s.sol:DeployScript \
--rpc-url http://localhost:8545 \
--private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 \
--broadcast
```

But the these commands are used in the makefile.

### dApp and metamask

After local contract deployment it is also needed to connect metamask to our local chain. When the user is logged in, in the metamask the procedure is following:

 1. Click to the network selection
 2. Scroll down and select add custom network
 3. Add network name, rpc url (localhost and port given by anvil) and chain ID (default is 31337)
 4. Lastly we can add all adresses generated by the anvil into the metamask and then test every role in the dApp

To manually generate contract ABI, run (in the dapp-wagmi dir):

```bash
 npx wagmi generate
```

I did not encounter a different smart contract address when deploying it, however if it would be different it would need to be changed in the `dapp-wagmi/src/config.ts` file.

## Implementation

### Smart contract

The smart contract functions are implemented in a single file and they mostly follow specifications given by the assignment. I firstly implemented the contract functions continuously with the tests, but I also later discovered some issues while implementing dApp, which I had to change in the smart contract aswell. I thought about splitting the contract into multiple smaller contracts but that would then make individual files very small, so I kept it at the end in a single file. Although for serious project it would be better individually for a little bit better clarity.

As for the component usage I heavily built-upon openzeppelin modules. The basic ERC20 functioanlity is derived from the openzeppelin, but also AccessControl module to manage roles, Capped extension to set maximum token cap and lastly Strings util for string manipulation in the functions that required signature handling (proposal functions).

#### Daily limit reset

I built the daily transfer limits to reset based on when you last used them, not the actual clock time.

Every transfer checks the timer:

- when you send tokens, the contract looks at the last time the limit was reset
- if it has been over 24 hours since then, the limit resets automatically
- if it is under 24 hours, it checks if the transfer would go over the limit

Advantages over midnight resets:

- nno double transfers by sending at 11:59 and again at 00:01
- the limit resets exactly 24 hours after your last transfer

Obviously these are also disadvantages if this is intended.

### dApp

Whole web application has a single component for navigation and then individual pages, defined in the `dapp-wagmi/src/pages` directory. The pages have single or multiple components defined in the `dapp-wagmi/src/components` directory where each component mostly aligns with the individual tasks given by the assignment.

As for the UI/UX of the application, on each page the action forms (for example transfer tokens) is only showed if the user has appropriate roles which is done with the Roles component. This component checks the roles with the `hasRole` contract function from the openzeppelin AccessControl and returns the object of booleans for each role. The website has simple dark-mode style so it is not plain HTML and it is defined in the `index.css` file.

The local chain is configured in the `dapp-wagmi/src/config.ts` that also contains contract address which is then used to call hooks that send transactions to the deployed contract.

### Tests

The smart contract tests are written in the `ERC20BDA.t.sol` file. Where I found it relevant I tried to test successful executions, failures and edge cases. The tests can be executed by running: `make test` or `forge test`

In a few tests I tried to utilize fuzzing variables, which are can be implemented very easily by just putting fuzzed variable as a test function parameter. I chose two mint functions and set transfer limit function because all of these functions have parameters that are quite long in the set of values that they can have but are also restricted with other checks, such as maxDailyLimit or transfer limit for the given user. As for the fuzzing settings I kept the default number of fuzzed values.

The list of tests where I used fuzzing is following:

- testMintSuccessful
- testMintDailyLimitExceeded
- testSetTransferLimit

## Completed tasks

### Smart contract (all)

- 1.1
- 1.2
- 1.3
- 1.4
- 1.5
- 1.6
- 1.7
- 1.8
- 1.9

### dApp (all except last two)

- 2.1
- 2.2
- 2.3
- 2.4
- 2.5
- 2.6
- 2.7
- 2.8

### Documentation (first three)

- 3.1
- 3.2
- 3.3

### Tests (first two)

- 4.1
- 4.2
